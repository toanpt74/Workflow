TRẮC NGHIỆM C++
BÀI 2
===================================================================
Câu 1: Giả sử cần khai báo biến Staff_Age để lưu trữ tuổi của nhân viên, hãy chọn kiểu dữ liệu phù hợp nhất cho biến Staff_Age
A. short int
B. long
C. float
D. double
Đúng, Đáp án đúng là short int
vì tuổi là số nguyên dương, do vậy sử dụng kiểu dữ liệu short int là phù hợp nhất
Câu 2: Giả sử cần khai báo biến Staff_Gender để lưu trữ giới tính của nhân viên, hãy chọn kiểu dữ liệu phù hợp nhất cho biến Staff_Gender
A. bool
B. float
c. double
D. string
Đúng, đáp án đúng là: bool
vì giới tính thường chỉ nhận hai giá trị là Nam hoặc Nữ, do vậy sử dụng kiểu dữ liệu bool là phù hợp nhất
Câu 3: Giả sử cần khai báo biến salary_coff để lưu trữ hệ số lương của nhân viên, hãy chọn kiểu dữ liệu phù hợp nhất cho biến salary_coff
A. float
B. bool
c. int
D. string
Đúng, đáp án đúng là: float
vì hệ số lương là số thực, do vậy sử dụng kiểu dữ liệu float là phù hợp nhất
Câu 4: Trong C++ giả sử đã khai báo và khởi tạo các biến a, b, c như sau:
  int a =32;
  int b = 33;
  char c = a+b; 
 Nếu sử dụng lệnh cout<<c; để hiển thị kết quả, khi đó kết quả hiển thị là gì?
A. A
B. 65
C. 66
D. Thông báo lỗi
Đúng, đáp án đúng là: A
Vì a+b = 32+33 = 65. Tuy nhiên biến c được khai báo là kiểu char, do vậy sẽ hiển thị chữ A (có mã Asscii là 65)
Câu 5: Trong C++ cho biến a = 5.5 và b=1.5. Lệnh nào sai?
A. a&=b;
B. a+=b;
C. a*=b;
D. a/=b;
Đúng, đáp án đúng là a&=b 
Vì phép toán & chỉ thực hiện trên kiểu dữ liệu rời rạc
Câu 6: Trong C++ cho hai biến kiểu int a và b, với giá trị lần lượt là 1 và 2. Biến nguyên x được gán như sau:
x = a<<b. Hỏi x có giá trị bằng bao nhiêu?
A. 1
B. 2
C. 4
D. 8
Đúng, đáp án đúng là: 4
Vì a = 1 = 0000.0000 0000.0001, khi thực hiện phép toán a << 2 thì kết quả sẽ dịch trái 2 bit=> x = 0000.0000 0000.0100 = 4

Câu 7: Trong C++, giả sử đã khai báo biến str là kiểu string, lệnh nào trả về độ dài của xâu str?
A. str.len()
B. str.length()
C. str.size()
D. len(str)
Đúng, đáp án đúng là str.size()
Vì theo ý nghĩa của phương thức size() trong c++
Câu 8: Trong C++, giả sử đã khai báo và khởi tạo giá trị cho các biến x, y như sau:
int x = 10;
int y = 100;
Biến z có giá trị bằng bao nhiêu? nếu thực hiện phép gán như sau: float z =(float)(x/y);
A. 0
B. 10
C. 0.1
D. 0.01
Đúng, đáp án đúng là 0
Vì khi thực hiện phép chia hai số nguyên, kết quả là một số nguyên. Do vậy z = 0

BÀI 4
============================================================================================================
Trong C++, giả sử đã khai báo hai biến như sau: 
int x = 10, y=11;
sau lệnh gán int z = ++x+y--;
giá trị của các biến x, y, z bằng bao nhiêu?
A. x = 11, y = 10, z = 22
B. x = 11, y = 11, z = 22
C. x = 10, y = 11, z = 21
D. x = 11, y = 11, z = 21
Đúng, đáp án đúng là x = 11, y = 10, z = 22
Vì lệnh z = ++x+y--; biến x tăng lên 1 (x = 11), sau đó sẽ gán z = x+y = 11+11 = 22, sau đó y được giảm đi 1 => do vậy y = 10.
Câu 2: Giả sử đã khai báo hai biến nguyên i, j. Đoạn chương trình sau sẽ in ra thông tin gì?
for(i=10; i<=20; i++)
  {
  	for(j=2; j<=i/j; j++)
    	if(!(i%j)) break;
    if(j> (i/j)) cout<<i<<",";
  }  
A. 11,13,17,19,
B. 10,12,14,16,18,20,
C. 11,13,17,
D. 11,13,15,17,19,
Đúng, đáp án đúng là: 11,13,17,19,
Vì đây là chương trình in ra các số nguyên tố trong đoạn [10, 20].

Câu 3: Trong C++, đoạn chương trình sau biến t có giá trị bằng bao nhiêu?
float t=0;  
for(int i=1; i<=5; i++)
	t+=(float)i/10;
A. 1
B. 1.5
C. 2
D. 0
Đúng, đáp án đúng là 1.5
Vì chương trình tính tổng 1/10 + 2/10 + 3/10 + 4/10 + 5/10 = 15/10 = 1.5

Câu 4: Trong C++, đoạn chương trình sau biến t có giá trị bằng bao nhiêu?
float t=0;  
for(int i=1; i<=5; i++)
	t+=(float)i/10;
A. 1
B. 1.5
C. 2
D. 0
Đúng, đáp án đúng là 0
Vì biến i khai báo kiểu int, nên i/10 = 0. Vậy tổng t = 0

Câu 5: Trong C++, khi kết thúc đoạn chương trình sau, biến t có giá trị bằng bao nhiêu?
int t=0;
for (m = 1, n = 1; m <= 3; m += 1, n += 2) {
        t+=n+m;
}
A. 10
B. 15
C. 20
D. 14
Đúng, đáp án đúng là 15
Vì mỗi lần lặp t được gán là t = t+n+m, khởi tạo m=n=1 => t = (1+1) +(2+3) + (3+5) = 15.

Câu 6: Trong C++, khẳng định nào đúng về đoạn mã lệnh sau
int t =0;
for(;;) t+=1;
A. Kết quả biến t có giá trị là 1
B. Kết quả biến t có giá trị là 0
C. Vòng lặp không thể kết thúc
D. Sai cú pháp lệnh lặp
Đúng, đáp án đúng là: Vòng lặp không thể kết thúc
Vì lệnh for không có biểu thức điều kiện
Câu 7: Trong C++, khi kết thúc đoạn chương trình sau biến t có giá trị bằng bao nhiêu?
int t =0, i=1;
for(;i<10;) t+=++i;
cout<<t;
A. 54
B. 55
D. 45
C. 57
Đúng, đáp án đúng là: 54
Vì chương trình sẽ tính tổng t = 2 + 3 +...+10 = 54

Câu 8: Trong C++, khi kết thúc đoạn chương trình sau biến t có giá trị bằng bao nhiêu?
int t =0, i=1;
for(;i<10;) t+=++i;
cout<<t;
A. 54
B. 55
D. 45
C. 57
Đúng, đáp án đúng là: 45
Vì chương trình sẽ tính tổng t = 1 + 3 +...+9 = 45

BÀI 5
===============

Câu 1: Trong c++ xét hàm như sau:
int thongbao(string u="No Name", int a=21)
{
	cout<<"Hello:"<<u<<", age:"<<a;
    return 0;
}
Cách gọi hàm nào đúng?
A. thongbao("Hai", 25);
B. thongbao(u="Hai", a=25);
C. thongbao(25, "Hai");
D. thongbao('Hai', 25);
Đúng, đáp án đúng là thongbao("Hai", 25)
Vì hàm thông báo có hai đối số là u kiểu string và a kiểu int, do vậy khi gọi hàm cần truyền vào đúng số lượng tham số và kiểu dữ liệu của tham số

Câu 2: Trong c++ xét hàm như sau:
int thongbao(string u="No Name", int a=21)
{
	cout<<"Hello:"<<u<<", age:"<<a;
    return 0;
}
Cách gọi hàm nào sai?
A. thongbao("Hai");
B. thongbao("Hai", 25);
C. thongbao(25);
D. thongbao();
Đúng, đáp án đúng là thongbao(25)
Vì hàm thông báo có hai đối số là u kiểu string và a kiểu int, do vậy khi gọi hàm cần truyền vào đúng số lượng tham số và kiểu dữ liệu của tham số

Câu 3: Trong C++, xét đoạn chương trình sau:
void modifyValue(int* ptr)
{ 
    (*ptr) += 10;
}
int main() {
	int localVar = 5;
	int* ptr = &localVar;      
	modifyValue(ptr);        
  return 0;
}
Kết thúc chương trình biến localVar có giá trị bằng bao nhiêu?
A. 5
B. 10
C. 15
D. 0
Đúng, đáp án đúng là 15
Vì hàm modifyValue có đối số là con trỏ và thực hiện tăng giá trị của đối số ptr lên 10 đơn vị, khởi tạo biến localVar có giá trị là 5, do vậy khi kết thúc hàm biến này sẽ tăng thêm 10 đơn vị => localVar = 15.
Câu 4: Trong C++, xét đoạn chương trình sau:
void modifyValue(int* ptr)
{ 
    (*ptr) += 10;
}
int main() {
	int localVar = 5;
    	int* ptr = &localVar;      
    	modifyValue(localVar);        
  return 0;
}
Kết thúc chương trình biến localVar có giá trị bằng bao nhiêu?
A. 5
B. 10
C. 15
D. Chương trình thông báo lỗi
Đúng, đáp án đúng là chương trình thông báo lỗi
Vì hàm modifyValue có đối số là con trỏ, khi gọi hàm phải truyền vào là địa chỉ của biến.

Câu 5: Trong C++, xét đoạn chương trình sau:
int x = 5; 
void Func()
{
	int y = 6;  	 
}
int main()
{
	int z = 7; 
}
Khẳng định nào đúng?
A. Có thể truy cập được tới biến x và y từ bên trong hàm Func()
B. Biến x và z là biến tổng thể
C. Biến x là cục bộ và z là biến tổng thể
D. Có thể truy cập được tới biến z và y trong hàm main()
Đúng, đáp án đúng là Có thể truy cập được tới biến x và y từ bên trong hàm Func()
Vì x là biến tổng thể và y là biến cục bộ của hàm Func(), do vậy có thể truy cập được tới hai biến này trong hàm Func()

Câu 6: Trong C++, xét đoạn chương trình sau:
int i;
int main(void) {
    for(i = 0; i < 1; i++) {
		int x;
		cout<< x++;
    }
    cout<<x<<endl;
    cout<<i<<endl;
    return 0;
}
Khẳng định nào đúng?
A. Chương trình thông báo lỗi do lệnh cout<<x<<endl;
B. Biến i là biến cục bộ của hàm main()
C. Chương trình thông báo lỗi do lệnh cout<<i<<endl;
D. Chương trình thông báo lỗi do lệnh cout<<x trong vòng lặp for
Đúng, đáp án đúng là: Chương trình thông báo lỗi do lệnh cout<<x<<endl;
Vì x là biến cục bộ trong vòng lặp for, do vậy không thể truy xuất từ bên ngoài vòng lặp.
Câu 7: Trong C++, xét đoạn chương trình sau:
int i;
void main(void) {
    for(i = 0; i < 1; i++) {
		int x=0;		
		x++;
    }
    cout<<"x="<<x<<endl;
    cout<<"i="<<i<<endl;
    return 0;
}
Khẳng định nào đúng?
A. Chương trình thông báo lỗi do lệnh cout<<"x="<<x<<endl;
B. Chương trình in ra x=1, i=1
C. Không thể truy cập tới biến i bên trong hàm main()
D. Không thể truy cập biến i bên trong vòng lặp for
Đúng, đáp án đúng là: Chương trình thông báo lỗi do lệnh cout<<"x="<<x<<endl;
Vì x là biến cục bộ trong vòng lặp for, do vậy không thể truy xuất từ bên ngoài vòng lặp.
Câu 8: Trong C++, xét đoạn chương trình sau:
#include <iostream>
using namespace std;
int x = 50;
int main()
{   
    int x = 10;
    cout <<::x;
    cout <<x; 
    return 0;
}
Khẳng định nào đúng?
A. Chương trình in ra giá trị là 5010
B. Chương trình in ra giá trị 1010
C. Chương trình thông báo lỗi vì khai báo hai biến cùng tên
D. Không thể truy cập biến x từ hàm main()
Đúng, đáp án đúng là: Chương trình in ra giá trị là 5010
Vì x biến tổng thể có giá trị 50 và một biến x là cục bộ và có giá trị là 10. DO vậy hai lệnh cout sẽ in ra giá trị của hai biến này => in ra 5010

BÀI 7
Câu 1: Trong C++, xét đoạn chương trình sau:
float *p;
float x=10;
p = &x;
float y= *(++p);
Giá trị của biến y bằng bao nhiêu?
A. 10
B. 11
C. Chương trình thông báo lỗi
D. y nhận một giá trị ngẫu nhiên
Đúng, đáp án đúng là: y nhận một giá trị ngẫu nhiên
Vì con trỏ p trỏ tới biến x, sau đó lệnh y =*(++p) sẽ nhận giá trị của ô nhớ sau biến x, đây là một giá trị ngẫu nhiên
Câu 2: Trong C++, xét đoạn chương trình sau:
float *p;
float x=10;
p = &x;
float y= *(p++);
Giá trị của biến y bằng bao nhiêu?
A. 10
B. 11
C. Chương trình thông báo lỗi
D. y nhận một giá trị ngẫu nhiên
Đúng, đáp án đúng là: 10
Vì con trỏ p trỏ tới biến x, sau đó lệnh y =*(p++) sẽ nhận giá trị của biến x => y =10
Câu 3: Trong C++, xét đoạn chương trình sau:
int a[] ={1, 2, 3,4};
int *ptr = a;
int t=0;
for(int i=0; i<sizeof(a)/sizeof(1);i++)
  	t+=*ptr++;
Hỏi biến t có giá trị như thế nào?
A. 10
B. 9
C. 11
D. Chương trình thông báo lỗi
Đúng, đáp án đúng là: 10
Vì đây là chương trình tính tổng các phần tử của mảng a => t = 1+2+3+4 = 10

Câu 4: Trong C++, làm thế nào để cấp phát vùng bộ nhớ động cho phép lưu trữ 10 số nguyên?
A. int arr[10];
B. int *arr = new int[10];
C. int *arr = malloc(10*sizeof(int));
D. int *arr = int[10]
Đúng, đáp án đúng là int *arr = new int[10];
Vì theo cú pháp lệnh cấp phát bộ nhớ động trong C++
Câu 5: Trong C++, khẳng định nào đúng về đoạn chương trình sau:
#include <iostream>
using namespace std;
int main() {
  int *ptr;
  ptr = new int;
  *ptr=7;  
  delete ptr;  
  cout<<*ptr;
  return 0;
}
A. Chương trình in ra số 0
B. Chương trình in ra số 7
C. Chương trình thông báo lỗi
D. Chương trình in ra địa chỉ của biến ptr
Đúng, đáp án đúng là: Chương trình in ra số 0
Vì lệnh cout<<*ptr đặt sau lệnh delete ptr, do vậy con trỏ này đã bị xóa => *ptr = 0
Câu 6: Trong C++, xét các lệnh sau:
int var1 = 5, var2=10;
  int *p1 = &var1;
  int *p2 = &var2;
  *p2 = *p1;
  cout<< var2;
Biến var2 có giá trị bằng baoo nhiêu?
A. 5
B. 10
C. 15
D. 0
Đúng, đáp án đúng là: 5
Vì lệnh gán *p2 = *p1 sẽ gán giá trị của biến được trỏ bởi con trỏ p2 bằng giá trị của biến được trỏ bởi con trỏ p1, bằng giá trị của biến var1 => var2 = 5.
Câu 7: Trong C++, xét đoạn chương trình sau:
#include <iostream>
using namespace std;
int main() {
  int arr[] ={1,2,3};
  int *ptr=arr;
  *(ptr+1) =*(ptr+1)+5;
  ptr++;
  *ptr =*(ptr-1) + 5;
  cout<<arr[0]<<" "<<arr[1]<<" "<<arr[2];
  return 0;
}
Kết quả in ra màn hình là gì?
A. 1 6 3
B. 1 7 3
C. 2 3 7
D. 1 3 6
Đúng, đáp án đúng là: 1 6 3
Vì: con trỏ ptr trỏ tới phần tử đầu tiên của mảng arr, lệnh *(ptr+1) = *(ptr+1) + 5 sẽ thay đổi giá trị của phần tử arr[1] thành 7. Tuy nhiên sau đó lệnh ptr++ sẽ trỏ con trỏ vào phần tử arr[1], và 
lệnh *ptr =*(ptr-1) + 5; sẽ thay đổi phần tử arr[1] = arr[0] + 5 = 6. Vậy kết quả là 1 6 3.
Câu 8: Trong C++, xét khai báo sau:
int *x, y;
Khẳng định nào đúng
A. x là con trỏ kiểu int, y là biến kiểu int
B. x và y là hai con trỏ kiểu int
C. x là biến kiểu int và y là con trỏ kiểu int
D. x và y là hai biến kiểu int
ĐÚng, đáp án đúng là: x là con trỏ kiểu int, y là biến kiểu int
Vì theo cú pháp khai báo biến và con trỏ trong C++


///////////////////////////////////////////////////////////////////
Tạo chương trình test cho các luồng công việc cụ thể
from test_funcs.compute_greedy_makespan import greedy_average_makespan
from test_funcs.sample_average_makespan import sample_average_makespan
from My_dataset_info import *
from MyDataloader import MyDataloader
from rcpsp_simulator.skip_env import Skip_environment
import numpy as np
import time

import os
import random
import time
from Params import args
from model.actor_critic import Agent
from rcpsp_simulator.normal_env import Normal_environment
from rcpsp_simulator.skip_env import Skip_environment

from MyDataloader import MyDataloader
from My_dataset_info import  *
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.distributions.categorical import Categorical
from torch.utils.tensorboard import SummaryWriter
import copy
from test_funcs.compute_greedy_makespan import greedy_average_makespan
from tqdm import tqdm
model_30 = r"D:\RCPSP\RL-RCPSP\saves\set_301160_321736313092.0018058.pt"

model = r"D:\RCPSP\RL-RCPSP\saves\set_301160_321736313092.0018058.pt"


dataloader_test_30 = MyDataloader(test_set_30)


n_samples = 30
greedy_test = False
normal_env = False
if_variant = False


## normal test ###
all_model = [model_30]
all_dataloader = [dataloader_test_30]



for model, dataloader in zip(all_model, all_dataloader):
    print(model)
    average_makespan, average_time = sample_average_makespan(model, dataloader, n_sampels=n_samples,
                                                             normal_env=normal_env, variant=if_variant,
                                                             greedy_test=greedy_test)
    print(average_makespan, average_time)
#Để lây thông tin về makespan của toàn bộ các job trong chương trình, thêm lệnh print(all_data_store) vào cuối tệp tin sample_average_makespan

///////////////////////////////////////////////////////////////////
feature_mat: là ma trận lưu trữ các thông tin về duration và resource của các job

///////////////////////////////////////////////////////////////////
Không gian trạng thái state được biểu diễn bởi các đặc trưng cơ bản:
+ jobdag: là đồ thị luồng công việc
jobdag = Jobdag(adj_mat, nodes_information, resource): tạo một đồ thị với ma trận kề, ma trận thuộc tính (chính là ma trận duration của các job trên các resource)
+ ma trận kề adjacency matrix
+ ma trận thuộc tính feature matrix
+ ma trận tài nguyên Resource excute
+ runable node index: một list VD: [0, 1, 2]
+ ma trận action_mask = có số chiều bằng số job, đây là ma trận nhị phân biểu diễn số trạng thái job được thực thi
 action_mask =[1, 1, 1, 0, 0, ...0] (khởi tạo có 3 job được thực thi là job 0, 1, 2)

+ action = 0, 1, 2,....,30.


